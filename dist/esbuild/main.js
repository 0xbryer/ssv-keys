"use strict";(()=>{var Ye=Object.create;var ye=Object.defineProperty;var Pe=Object.getOwnPropertyDescriptor;var He=Object.getOwnPropertyNames;var Ce=Object.getPrototypeOf,Ue=Object.prototype.hasOwnProperty;var n=(s=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(s,{get:(e,r)=>(typeof require!="undefined"?require:e)[r]}):s)(function(s){if(typeof require!="undefined")return require.apply(this,arguments);throw new Error('Dynamic require of "'+s+'" is not supported')});var $e=(s,e,r,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let a of He(e))!Ue.call(s,a)&&a!==r&&ye(s,a,{get:()=>e[a],enumerable:!(t=Pe(e,a))||t.enumerable});return s};var x=(s,e,r)=>(r=s!=null?Ye(Ce(s)):{},$e(e||!s||!s.__esModule?ye(r,"default",{value:s,enumerable:!0}):r,s));var p=(s,e,r,t)=>{for(var a=t>1?void 0:t?Pe(e,r):e,i=s.length-1,o;i>=0;i--)(o=s[i])&&(a=(t?o(e,r,a):o(a))||a);return t&&a&&ye(e,r,a),a};var y=(s,e,r)=>new Promise((t,a)=>{var i=d=>{try{h(r.next(d))}catch(c){a(c)}},o=d=>{try{h(r.throw(d))}catch(c){a(c)}},h=d=>d.done?t(d.value):Promise.resolve(d.value).then(i,o);h((r=r.apply(s,e)).next())});var Ne=x(n("atob"));var ue;try{window.crypto,ue=n("bls-eth-wasm/browser")}catch(s){ue=n("bls-eth-wasm")}var u=ue;var Ee=n("js-base64");var m=n("class-validator");var Te=x(n("underscore")),f=n("class-validator");var b=n("class-validator");var W=n("class-validator");var ve=n("js-base64");var he;try{window.crypto,he=n("jsencrypt").JSEncrypt}catch(s){he=n("node-jsencrypt")}var F=he;var M=n("js-base64");var D=class extends Error{constructor(r,t){super(t);this.operator=r}},O=class{constructor(e,r){this.RAW_OPERATOR_PUBLIC_KEY_SIGNATURE=RegExp(/------BEGIN RSA PUBLIC KEY-----/,"gmi");this.operators=e.map(t=>this.RAW_OPERATOR_PUBLIC_KEY_SIGNATURE.test(t)?t:(0,M.decode)(t)),this.shares=r}encrypt(){let e=[];return Object.keys(this.operators).forEach(r=>{let t=new F({});try{t.setPublicKey(this.operators[r])}catch(o){throw new D({rsa:this.operators[r],base64:(0,M.encode)(this.operators[r])},`Operator is not valid RSA Public Key: ${o}`)}let a=t.encrypt(this.shares[r].privateKey),i={operatorPublicKey:this.operators[r],privateKey:String(a),publicKey:this.shares[r].publicKey};return e.push(i),i}),e}};var Ae=s=>{try{let e="Invalid operator key format, make sure the operator exists in the network",r=(0,ve.decode)(s);if(s.length<98)throw Error("The length of the operator public key must be at least 98 characters.");if(!r.startsWith("-----BEGIN RSA PUBLIC KEY-----"))throw Error(e);let t=new F({});try{t.setPublicKey(r)}catch(a){throw new D({rsa:r,base64:s},e)}return!0}catch(e){let{message:r}=e;return r}};var X=class extends Error{constructor(r,t){super(t);this.operator=r}},z=class extends Error{constructor(r,t){super(t);this.operator=r}},L=class extends Error{constructor(r,t,a){super(a);this.listOne=r,this.listTwo=t}},J=class extends Error{constructor(r,t){super(t);this.publicKey=r}};var N=class{validate(e){let r=Ae(e);if(r!==!0)throw new J(e,`${r}`);return!0}defaultMessage(){return"Invalid operator public key"}};N=p([(0,W.ValidatorConstraint)({name:"operatorPublicKey",async:!1})],N);function De(s){return function(e,r){(0,W.registerDecorator)({target:e.constructor,propertyName:r,options:s,constraints:[],validator:N})}}var k=class{setData(e){e.id&&(this.id=e.id),e.publicKey&&(this.publicKey=e.publicKey)}validate(){(0,b.validateSync)(this)}};p([(0,b.IsNotEmpty)({message:"The operator id is null"}),(0,b.IsDefined)({message:"The operator id is undefined"}),(0,b.IsInt)({message:"The operator id must be an integer"})],k.prototype,"id",2),p([(0,b.IsNotEmpty)({message:"The operator public key is null"}),(0,b.IsDefined)({message:"The operator public key is undefined"}),(0,b.IsString)({message:"The operator public key must be a string"}),De()],k.prototype,"publicKey",2);var w=n("class-validator");var q=n("class-validator");var Y=class{validate(e,r){let[t,a]=r.constraints,i=r.object[t].length;if(!Array.isArray(e))Object.values(e).forEach(o=>{if(i!==o.length)throw new L(r.object[t],e,a.message)});else if(i!==e.length)throw new L(r.object[t],e,a.message);return!0}defaultMessage(){return"The length of the entries lists are not equal"}};Y=p([(0,q.ValidatorConstraint)({name:"matchLength",async:!1})],Y);function G(s,e){return function(r,t){(0,q.registerDecorator)({target:r.constructor,propertyName:t,options:e,constraints:[s,e],validator:Y})}}var Z=n("class-validator");var Q=class extends Error{constructor(r,t){super(t);this.publicKey=r}};var H=class{validate(e){return y(this,null,function*(){try{yield u.init(u.BLS12_381),typeof e=="string"?u.deserializeHexStrToPublicKey(e.replace("0x","")):e.forEach(r=>u.deserializeHexStrToPublicKey(r.replace("0x","")))}catch(r){throw new Q(e,"Failed to BLS deserialize validator public key")}return!0})}defaultMessage(){return"Invalid public key"}};H=p([(0,Z.ValidatorConstraint)({name:"publicKey",async:!0})],H);function ee(s){return function(e,r){(0,Z.registerDecorator)({target:e.constructor,propertyName:r,options:s,constraints:[],validator:H})}}var re=n("class-validator"),_e=n("js-base64");var Oe=x(n("web3")),_=new Oe.default,ke=(s,e)=>s.map(r=>{let t=e?Object(r)[e]:r;return String(t).startsWith("0x")?t:_.eth.abi.encodeParameter("string",t)});var C=class{validate(e){let r="";try{(Array.isArray(e)?e:[e]).forEach(a=>{r=a,(0,_e.decode)(a.startsWith("0x")?_.eth.abi.decodeParameter("string",a):a)})}catch(t){throw Error(`Filed ABI decode shares encrypted key: ${r}. Error: ${t.message}`)}return!0}defaultMessage(){return"Filed ABI decode shares encrypted key"}};C=p([(0,re.ValidatorConstraint)({name:"encryptedKey",async:!1})],C);function Re(s){return function(e,r){(0,re.registerDecorator)({target:e.constructor,propertyName:r,options:s,constraints:[],validator:C})}}var R=class{setData(e){e.publicKeys&&(this.publicKeys=e.publicKeys),e.encryptedKeys&&(this.encryptedKeys=e.encryptedKeys)}validate(){(0,w.validateSync)(this)}};p([(0,w.IsArray)(),(0,w.MinLength)(98,{each:!0}),ee({each:!0})],R.prototype,"publicKeys",2),p([(0,w.IsArray)(),(0,w.MinLength)(98,{each:!0}),G("publicKeys",{message:"Length of encrypted and public keys should be equal."}),Re()],R.prototype,"encryptedKeys",2);var te=n("class-validator");var U=class{validate(e){let r=new Set,t=new Set;for(let a of e||[]){if(r.has(a.id))throw new X(a,"Operator ID already exists");if(r.add(a.id),t.has(a.publicKey))throw new z(a,"Operator public key already exists");t.add(a.publicKey)}return!0}defaultMessage(){return"The list of operators contains duplicate entries"}};U=p([(0,te.ValidatorConstraint)({name:"uniqueList",async:!1})],U);function Ve(s){return function(e,r){(0,te.registerDecorator)({target:e.constructor,propertyName:r,options:s,constraints:[],validator:U})}}var E=class{constructor(){this.publicKey=null;this.operators=null;this.shares=null}setData(e){if(e.publicKey&&(this.publicKey=e.publicKey),e.operators&&(this.operators=e.operators.sort((r,t)=>+r.id-+t.id).map(r=>{if(!r.id||!r.publicKey)throw Error("Mismatch amount of operator ids and operator keys.");let t=new k;return t.setData(r),t})),e.encryptedShares){let r=new R;Te.default.isArray(e.encryptedShares)?r.setData({publicKeys:e.encryptedShares.map(t=>t.publicKey),encryptedKeys:e.encryptedShares.map(t=>t.privateKey)}):r.setData(e.encryptedShares),this.shares=r}}validate(){return y(this,null,function*(){(0,f.validateSync)(this)})}get sharesPublicKeys(){var e;return((e=this.shares)==null?void 0:e.publicKeys)||[]}get sharesEncryptedKeys(){var e;return((e=this.shares)==null?void 0:e.encryptedKeys)||[]}get operatorIds(){var e;return(e=this.operators)!=null&&e.length?this.operators.map(r=>parseInt(String(r.id),10)):[]}get operatorPublicKeys(){var e;return(e=this.operators)!=null&&e.length?this.operators.map(r=>String(r.publicKey)):[]}};p([(0,f.IsOptional)(),(0,f.IsString)(),(0,f.Length)(98,98),ee()],E.prototype,"publicKey",2),p([(0,f.IsOptional)(),(0,f.ValidateNested)({each:!0}),Ve()],E.prototype,"operators",2),p([(0,f.IsOptional)(),(0,f.ValidateNested)(),G("operators",{message:"Length of operators and shares should be equal."})],E.prototype,"shares",2);var de=x(n("underscore"));var A=n("class-validator");var V=class{constructor(){this.readable=null;this.raw=void 0}build(e){return[e.publicKey,e.operatorIds,e.encryptedShares.map(r=>r.publicKey),ke(e.encryptedShares,"privateKey")]}setData(e){if(!e===null){this.raw=void 0,this.readable=null;return}if(de.default.isArray(e)){this.raw=this.toRaw(e),this.readable=this.toReadable(e);return}de.default.isObject(e)&&(e.readable&&(this.readable=e.readable),e.raw&&(this.raw=e.raw))}toRaw(e){return e.join(",")}toReadable(e){return{publicKey:e[V.PAYLOAD_INDEX_VALIDATOR_PUBLIC_KEY],operatorIds:e[V.PAYLOAD_INDEX_OPERATOR_IDS],sharePublicKeys:e[V.PAYLOAD_INDEX_SHARE_PUBLIC_KEYS],sharePrivateKey:e[V.PAYLOAD_INDEX_SHARE_PRIVATE_KEYS],amount:"Amount of SSV tokens to be deposited to your validator's cluster balance (mandatory only for 1st validator in a cluster)"}}validate(){return y(this,null,function*(){})}},S=V;S.PAYLOAD_INDEX_VALIDATOR_PUBLIC_KEY=0,S.PAYLOAD_INDEX_OPERATOR_IDS=1,S.PAYLOAD_INDEX_SHARE_PUBLIC_KEYS=2,S.PAYLOAD_INDEX_SHARE_PRIVATE_KEYS=3,p([(0,A.IsOptional)(),(0,A.IsObject)()],S.prototype,"readable",2),p([(0,A.IsOptional)(),(0,A.IsString)()],S.prototype,"raw",2);var se=class extends E{};var me=x(n("underscore")),ae=x(n("ethers")),ie=n("class-validator");var $=class{constructor(){this.readable=null}decodeRSAShares(e){return e.map(r=>"0x"+Buffer.from(r,"base64").toString("hex"))}sharesToBytes(e,r){let t=this.decodeRSAShares(r),a=new Uint8Array(e.map(l=>[...ae.utils.arrayify(l)]).flat()),i=new Uint8Array(t.map(l=>[...ae.utils.arrayify(l)]).flat()),o=ae.utils.hexlify(a),h=String(o.length.toString(16)).padStart(4,"0"),d=Buffer.concat([a,i]),c=`0x${h}${d.toString("hex")}`;return c.length!==2438?(console.log("error",a.length,i.length,h,c),console.log("error",t)):(console.log("ok",a.length,i.length,h),console.log("ok",t)),c}build(e){return[e.publicKey,e.operatorIds,this.sharesToBytes(e.encryptedShares.map(r=>r.publicKey),e.encryptedShares.map(r=>r.privateKey))]}setData(e){if(!e===null){this.readable=null;return}if(me.default.isArray(e)){this.readable=this.toReadable(e);return}me.default.isObject(e)&&e.readable&&(this.readable=e.readable)}toRaw(e){return e.join(",")}toReadable(e){return{publicKey:e[$.PAYLOAD_INDEX_VALIDATOR_PUBLIC_KEY],operatorIds:e[$.PAYLOAD_INDEX_OPERATOR_IDS],shares:e[$.PAYLOAD_INDEX_SHARES_KEYS],amount:"Amount of SSV tokens to be deposited to your validator's cluster balance (mandatory only for 1st validator in a cluster)",cluster:"The latest cluster snapshot data, obtained using the cluster-scanner tool. If this is the cluster's 1st validator then use - {0,0,0,0,0,false}"}}validate(){}},P=$;P.PAYLOAD_INDEX_VALIDATOR_PUBLIC_KEY=0,P.PAYLOAD_INDEX_OPERATOR_IDS=1,P.PAYLOAD_INDEX_SHARES_KEYS=2,p([(0,ie.IsOptional)(),(0,ie.IsObject)()],P.prototype,"readable",2);var T=class{constructor({version:e}){this.byVersion={payload:{[T.VERSION_V2]:S,[T.VERSION_V3]:P},data:{[T.VERSION_V2]:E,[T.VERSION_V3]:se}};this.version=e,this.data=this.getByVersion("data",e),this.payload=this.getByVersion("payload",e)}generateContractPayload(e){var t;let r=this.payload.build(e);return(t=this.payload)==null||t.setData(r),this.payload}setData(e){!e||(this.data.setData(e),this.validate())}getByVersion(e,r){if(!this.byVersion[e])throw Error(`"${e}" is unknown entity`);if(!this.byVersion[e][r])throw Error(`"${e}" is not supported in version of key shares: ${r}`);return new this.byVersion[e][r]}validate(){(0,m.validateSync)(this)}fromJson(e){return typeof e=="string"&&(e=JSON.parse(e)),this.setData(e.data),this}toJson(){return JSON.stringify({version:this.version,data:this.data||null,payload:this.payload||null,createdAt:new Date().toISOString()},null,"  ")}},K=T;K.VERSION_V2="v2",K.VERSION_V3="v3",p([(0,m.IsString)(),(0,m.IsDefined)(),(0,m.IsNotEmpty)()],K.prototype,"version",2),p([(0,m.IsOptional)(),(0,m.ValidateNested)()],K.prototype,"data",2),p([(0,m.IsOptional)(),(0,m.ValidateNested)()],K.prototype,"payload",2);var fe=class{constructor(){this.operatorsCount=3}setOperatorsCount(e){this.operatorsCount=e}},Be=s=>!(s<4||s>13||s%3!=1),Mr=new fe;var be=class extends Error{constructor(r,t){super(t);this.operators=r}},ge=class extends Error{constructor(r,t){super(t);this.operator=r}},Se=class{constructor(){this.shares=[]}static get DEFAULT_THRESHOLD_NUMBER(){return 3}create(e,r){return y(this,null,function*(){r.map(c=>{if(!Number.isInteger(c))throw new ge(c,`Operator must be integer. Got: ${c}`)});let t=[...r].sort((c,l)=>c-l),a=t.length;if(!Be(a))throw new be(t,"Invalid operators amount. Enter an 3f+1 compatible amount of operator ids.");yield u.init(u.BLS12_381);let i=[],o=[];this.privateKey=u.deserializeHexStrToSecretKey(e),this.publicKey=this.privateKey.getPublicKey(),i.push(this.privateKey),o.push(this.publicKey);let h=(a-1)/3;for(let c=1;c<a-h;c+=1){let l=new u.SecretKey;l.setByCSPRNG(),i.push(l);let I=l.getPublicKey();o.push(I)}for(let c of t){let l=new u.Id;l.setInt(c);let I=new u.SecretKey;I.share(i,l);let v=new u.PublicKey;v.share(o,l),this.shares.push({privateKey:`0x${I.serializeToHexStr()}`,publicKey:`0x${v.serializeToHexStr()}`,id:l})}return{privateKey:`0x${this.privateKey.serializeToHexStr()}`,publicKey:`0x${this.publicKey.serializeToHexStr()}`,shares:this.shares}})}},oe=Se;var Ke=x(n("crypto")),Le=n("scrypt-js"),ne=x(n("ethereumjs-wallet")),pe=n("ethereumjs-util");var Ie=class{constructor(e){this.privateKey="";if(!e)throw new Error("Key store data should be JSON or string");if(typeof e=="string"?this.keyStoreData=JSON.parse(e):this.keyStoreData=e,!this.keyStoreData.version)throw new Error("Invalid keystore file")}getPublicKey(){var e;if(this.keyStoreData)switch((e=this.keyStoreData.version)!=null?e:this.keyStoreData.Version){case 1:return this.keyStoreData.Address;case 3:return this.keyStoreData.id;case 4:return this.keyStoreData.pubkey}return""}getPrivateKey(e=""){return y(this,null,function*(){if(this.privateKey)return this.privateKey;switch(this.keyStoreData.version){case 1:this.wallet=yield ne.default.fromV1(this.keyStoreData,e);break;case 3:this.wallet=yield ne.default.fromV3(this.keyStoreData,e,!0);break;case 4:this.wallet=yield this.fromV4(this.keyStoreData,e);break}if(this.wallet&&(this.privateKey=this.wallet.getPrivateKey().toString("hex"),!this.privateKey))throw new Error("Invalid password");return this.privateKey})}fromV4(e,r){return y(this,null,function*(){let t=typeof e=="object"?e:JSON.parse(e);if(t.version!==4)throw new Error("Not a V4 wallet");let a,i;if(t.crypto.kdf.function==="scrypt")i=t.crypto.kdf.params,a=(0,Le.syncScrypt)(Buffer.from(r),Buffer.from(i.salt,"hex"),i.n,i.r,i.p,i.dklen);else if(t.crypto.kdf.function==="pbkdf2"){if(i=t.crypto.kdf.params,i.prf!=="hmac-sha256")throw new Error("Unsupported parameters to PBKDF2");a=Ke.default.pbkdf2Sync(Buffer.from(r),Buffer.from(i.salt,"hex"),i.c,i.dklen,"sha256")}else throw new Error("Unsupported key derivation scheme");let o=Buffer.from(t.crypto.cipher.message,"hex"),h=Buffer.concat([Buffer.from(a.slice(16,32)),o]),c={keccak256:pe.keccak256,sha256:pe.sha256}[t.crypto.checksum.function];if(c(h).toString("hex")!==t.crypto.checksum.message)throw new Error("Invalid password");let I=Ke.default.createDecipheriv(t.crypto.cipher.function,a.slice(0,16),Buffer.from(t.crypto.cipher.params.iv,"hex")),v=this.runCipherBuffer(I,o);return new ne.default(v)})}runCipherBuffer(e,r){return Buffer.concat([e.update(r),e.final()])}static toHexString(e){return Array.from(e,r=>`0${(r&255).toString(16)}`.slice(-2)).join("")}},ce=Ie;var le=class{constructor(e){if(!Object.values(le.VERSION).includes(e))throw Error("Version is not supported");this.version=e,this.keySharesInstance=new K({version:this.version})}get keyShares(){return this.keySharesInstance}getPrivateKeyFromKeystoreData(e,r){return y(this,null,function*(){try{let t=yield new ce(e).getPrivateKey(r);return yield u.init(u.BLS12_381),this.privateKey=`0x${u.deserializeHexStrToSecretKey(t).serializeToHexStr()}`,this.publicKey=`0x${u.deserializeHexStrToSecretKey(t).getPublicKey().serializeToHexStr()}`,t}catch(t){return t}})}createThreshold(e,r){return y(this,null,function*(){return this.threshold=yield new oe().create(e,r),this.threshold})}encryptShares(e,r,t=""){return y(this,null,function*(){try{let a=e.map(o=>String((0,Ee.encode)((0,Ne.default)(o))));return new O(a,r).encrypt().map(o=>(o.operatorPublicKey=(0,Ee.encode)(o.operatorPublicKey),t===le.SHARES_FORMAT_ABI&&(o.operatorPublicKey=_.eth.abi.encodeParameter("string",o.operatorPublicKey),o.privateKey=_.eth.abi.encodeParameter("string",o.privateKey)),o))}catch(a){return a}})}buildShares(e,r,t){return y(this,null,function*(){if(r.length!==t.length)throw Error("Mismatch amount of operator ids and operator keys.");let a=r.map((o,h)=>({id:o,publicKey:t[h]})).sort((o,h)=>+o.id-+h.id),i=yield this.createThreshold(e,a.map(o=>o.id));return this.encryptShares(a.map(o=>o.publicKey),i.shares)})}getThreshold(){return this.threshold}buildPayload(e){return y(this,null,function*(){return this.keyShares.generateContractPayload({publicKey:e.publicKey,operatorIds:[...e.operatorIds].sort((r,t)=>r-t),encryptedShares:e.encryptedShares})})}buildPayloadFromKeyShares(e){return y(this,null,function*(){var d,c,l,I,v,xe,we;let r=((c=(d=e.data)==null?void 0:d.shares)==null?void 0:c.publicKeys)||[],t=(l=e.data)==null?void 0:l.publicKey,a=((v=(I=e.data)==null?void 0:I.shares)==null?void 0:v.encryptedKeys)||[],i=(xe=e.data.operators)==null?void 0:xe.map(g=>g.publicKey),h=((we=e.data.operators)==null?void 0:we.map(g=>g.id)).map((g,B)=>({id:g,publicKey:i[B]})).sort((g,B)=>+g.id-+B.id);if(r.length!==a.length||r.length!==i.length||a.length!==i.length||!a.length||!i.length||!r.length)throw Error("Operator public keys and shares public/encrypted keys length does not match or have zero length.");return this.keyShares.generateContractPayload({publicKey:t,operatorIds:h.map(g=>g.id),encryptedShares:r.map((g,B)=>({publicKey:g,privateKey:a[B]}))})})}},j=le;j.SHARES_FORMAT_ABI="abi",j.VERSION={V2:"v2",V3:"v3"};})();
