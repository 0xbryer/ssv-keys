(()=>{var tr=Object.create;var k=Object.defineProperty;var j=Object.getOwnPropertyDescriptor;var sr=Object.getOwnPropertyNames;var ar=Object.getPrototypeOf,ir=Object.prototype.hasOwnProperty;var c=(a=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(a,{get:(r,e)=>(typeof require!="undefined"?require:r)[e]}):a)(function(a){if(typeof require!="undefined")return require.apply(this,arguments);throw new Error('Dynamic require of "'+a+'" is not supported')});var or=(a,r)=>{for(var e in r)k(a,e,{get:r[e],enumerable:!0})},nr=(a,r,e,t)=>{if(r&&typeof r=="object"||typeof r=="function")for(let s of sr(r))!ir.call(a,s)&&s!==e&&k(a,s,{get:()=>r[s],enumerable:!(t=j(r,s))||t.enumerable});return a};var S=(a,r,e)=>(e=a!=null?tr(ar(a)):{},nr(r||!a||!a.__esModule?k(e,"default",{value:a,enumerable:!0}):e,a));var h=(a,r,e,t)=>{for(var s=t>1?void 0:t?j(r,e):r,i=a.length-1,o;i>=0;i--)(o=a[i])&&(s=(t?o(r,e,s):o(s))||s);return t&&s&&k(r,e,s),s};var n=(a,r,e)=>new Promise((t,s)=>{var i=d=>{try{l(e.next(d))}catch(m){s(m)}},o=d=>{try{l(e.throw(d))}catch(m){s(m)}},l=d=>d.done?t(d.value):Promise.resolve(d.value).then(i,o);l((e=e.apply(a,r)).next())});var G=S(c("atob")),q=S(c("web3")),L=c("js-base64"),M=S(c("eth2-keystore-js"));var W;try{window.crypto,W=c("bls-eth-wasm/browser")}catch(a){W=c("bls-eth-wasm")}var p=W;var $=class extends Error{constructor(e,t){super(t);this.operators=e}},_=class extends Error{constructor(e,t){super(t);this.operator=e}},F=class{constructor(){this.shares=[]}static get DEFAULT_THRESHOLD_NUMBER(){return 3}create(r,e){return n(this,null,function*(){e.map(s=>{if(!Number.isInteger(s))throw new _(s,`Operator must be integer. Got: ${String(s)}`)});let t=(e.length-1)/3;if(!Number.isInteger(t))throw new $(e,"Invalid operators length. It should satisfy conditions: \u2016 Operators \u2016 := 3 * F + 1 ; F \u2208 \u2115");return new Promise((s,i)=>{try{p.init(p.BLS12_381).then(()=>{let o=[],l=[];this.validatorPrivateKey=p.deserializeHexStrToSecretKey(r),this.validatorPublicKey=this.validatorPrivateKey.getPublicKey(),o.push(this.validatorPrivateKey),l.push(this.validatorPublicKey);for(let m=1;m<e.length-t;m+=1){let f=new p.SecretKey;f.setByCSPRNG(),o.push(f);let K=f.getPublicKey();l.push(K)}for(let m of e){let f=new p.Id;f.setInt(m);let K=new p.SecretKey;K.share(o,f);let I=new p.PublicKey;I.share(l,f),this.shares.push({privateKey:`0x${K.serializeToHexStr()}`,publicKey:`0x${I.serializeToHexStr()}`,id:f})}let d={validatorPrivateKey:`0x${this.validatorPrivateKey.serializeToHexStr()}`,validatorPublicKey:`0x${this.validatorPublicKey.serializeToHexStr()}`,shares:this.shares};s(d)})}catch(o){i(o)}})})}},B=F;var O=c("js-base64");var C;try{window.crypto,C=c("jsencrypt").JSEncrypt}catch(a){C=c("node-jsencrypt")}var D=C;var P=class extends Error{constructor(e,t){super(t);this.operator=e}},v=class{constructor(r,e){this.RAW_OPERATOR_PUBLIC_KEY_SIGNATURE=RegExp(/------BEGIN RSA PUBLIC KEY-----/,"gmi");this.operators=r.map(t=>this.RAW_OPERATOR_PUBLIC_KEY_SIGNATURE.test(t)?t:(0,O.decode)(t)),this.shares=e}encrypt(){let r=[];return Object.keys(this.operators).forEach(e=>{let t=new D({});try{t.setPublicKey(this.operators[e])}catch(o){throw new P({rsa:this.operators[e],base64:(0,O.encode)(this.operators[e])},`Operator is not valid RSA Public Key: ${o}`)}let s=t.encrypt(this.shares[e].privateKey),i={operatorPublicKey:this.operators[e],privateKey:String(s),publicKey:this.shares[e].publicKey};return r.push(i),i}),r}};var H=class{constructor(){this.web3Instances={}}getWeb3(r=process.env.NODE_URL||""){return this.web3Instances[r]||(this.web3Instances[r]=new q.default(String(r||""))),this.web3Instances[r]}getPrivateKeyFromKeystoreData(r,e){return n(this,null,function*(){try{try{r=JSON.parse(r)}catch(s){}return yield new M.default(r).getPrivateKey(e).then(s=>s)}catch(t){return t}})}createThreshold(r,e){return n(this,null,function*(){try{return new B().create(r,e)}catch(t){return t}})}encryptShares(r,e,t=""){return n(this,null,function*(){try{let s=r.map(o=>String((0,L.encode)((0,G.default)(o))));return new v(s,e).encrypt().map(o=>(o.operatorPublicKey=(0,L.encode)(o.operatorPublicKey),t===H.SHARES_FORMAT_ABI&&(o.operatorPublicKey=this.getWeb3().eth.abi.encodeParameter("string",o.operatorPublicKey),o.privateKey=this.getWeb3().eth.abi.encodeParameter("string",o.privateKey)),o))}catch(s){return s}})}abiEncode(r,e){return r.map(t=>{let s=Object(t)[e];return String(s).startsWith("0x")?s:this.getWeb3().eth.abi.encodeParameter("string",s)})}buildPayload(r,e,t,s){return n(this,null,function*(){let i=t.map(l=>l.publicKey),o=this.abiEncode(t,"privateKey");return[r,e.join(","),i,o,s]})}},A=H;A.SHARES_FORMAT_ABI="abi";var J=S(c("crypto")),Y=c("scrypt-js"),R=S(c("ethereumjs-wallet")),N=c("ethereumjs-util"),U=class{constructor(r){this.privateKey="";if(!r)throw new Error("Key store data should be JSON or string");if(this.keyStoreData=JSON.parse(String(r)),!this.keyStoreData.version)throw new Error("Invalid keystore file")}getPublicKey(){var r;if(this.keyStoreData)switch((r=this.keyStoreData.version)!=null?r:this.keyStoreData.Version){case 1:return this.keyStoreData.Address;case 3:return this.keyStoreData.id;case 4:return this.keyStoreData.pubkey}return""}getPrivateKey(r=""){return n(this,null,function*(){if(this.privateKey)return this.privateKey;switch(this.keyStoreData.version){case 1:this.wallet=yield R.default.fromV1(this.keyStoreData,r);break;case 3:this.wallet=yield R.default.fromV3(this.keyStoreData,r,!0);break;case 4:this.wallet=yield this.fromV4(this.keyStoreData,r);break}if(this.wallet&&(this.privateKey=this.wallet.getPrivateKey().toString("hex"),!this.privateKey))throw new Error("Invalid password");return this.privateKey})}fromV4(r,e){return n(this,null,function*(){let t=typeof r=="object"?r:JSON.parse(r);if(t.version!==4)throw new Error("Not a V4 wallet");let s,i;if(t.crypto.kdf.function==="scrypt")i=t.crypto.kdf.params,s=yield(0,Y.scrypt)(Buffer.from(e),Buffer.from(i.salt,"hex"),i.n,i.r,i.p,i.dklen);else if(t.crypto.kdf.function==="pbkdf2"){if(i=t.crypto.kdf.params,i.prf!=="hmac-sha256")throw new Error("Unsupported parameters to PBKDF2");s=J.default.pbkdf2Sync(Buffer.from(e),Buffer.from(i.salt,"hex"),i.c,i.dklen,"sha256")}else throw new Error("Unsupported key derivation scheme");let o=Buffer.from(t.crypto.cipher.message,"hex"),l=Buffer.concat([Buffer.from(s.slice(16,32)),o]);if({keccak256:N.keccak256,sha256:N.sha256}[t.crypto.checksum.function](l).toString("hex")!==t.crypto.checksum.message)throw new Error("Invalid password");let K=J.default.createDecipheriv(t.crypto.cipher.function,s.slice(0,16),Buffer.from(t.crypto.cipher.params.iv,"hex")),I=this.runCipherBuffer(K,o);return new R.default(I)})}runCipherBuffer(r,e){return Buffer.concat([r.update(e),r.final()])}static toHexString(r){return Array.from(r,e=>`0${(e&255).toString(16)}`.slice(-2)).join("")}},Q=U;var u=c("class-validator");var z={};or(z,{KeySharesDataV2:()=>g,KeySharesKeysV2:()=>w,OperatorV2:()=>E});var rr=S(c("web3")),er=c("js-base64"),y=c("class-validator");var X=c("js-base64");var Z=a=>n(void 0,null,function*(){try{let r="Invalid operator key format, make sure the operator exists in the network",e=(0,X.decode)(a);if(!e.startsWith("-----BEGIN RSA PUBLIC KEY-----"))throw Error(r);let t=new D({});try{t.setPublicKey(e)}catch(s){throw new P({rsa:e,base64:a},r)}return!0}catch(r){let{message:e}=r;return e}});var cr=new rr.default,w=class{constructor(r,e){this.publicKeys=r,this.encryptedKeys=e}};h([(0,y.IsArray)(),(0,y.MinLength)(98,{each:!0})],w.prototype,"publicKeys",2),h([(0,y.IsArray)(),(0,y.MinLength)(98,{each:!0})],w.prototype,"encryptedKeys",2);var E=class{constructor(r,e){this.id=r,this.publicKey=e}};h([(0,y.IsInt)()],E.prototype,"id",2),h([(0,y.IsString)(),(0,y.MinLength)(98)],E.prototype,"publicKey",2);var g=class{constructor(r){this.publicKey=r.publicKey,this.operators=r.operators.map(e=>new E(e.id,e.publicKey)),this.shares=new w(r.shares.publicKeys,r.shares.encryptedKeys)}get sharesPublicKeys(){var r;return((r=this.shares)==null?void 0:r.publicKeys)||null}get sharesEncryptedKeys(){var r;return((r=this.shares)==null?void 0:r.encryptedKeys)||null}get operatorIds(){return this.operators.map(r=>r.id)}get operatorPublicKeys(){return this.operators.map(r=>r.publicKey)}validateValidatorPublicKey(){return n(this,null,function*(){try{p.deserializeHexStrToPublicKey(this.publicKey.replace("0x",""))}catch(r){throw Error(`Can not BLS deserialize validator public key: ${this.publicKey}. Error: ${String(r)}`)}})}validateSharesPublicKeys(){return n(this,null,function*(){var e;if(!((e=this.sharesPublicKeys)!=null&&e.length))return;let r="";try{for(let t of this.sharesPublicKeys)r=t,p.deserializeHexStrToPublicKey(t.replace("0x",""))}catch(t){throw Error(`Can not BLS deserialize shares public key: ${r}. Error: ${String(t)}`)}})}validateSharesEncryptedKeys(){return n(this,null,function*(){var e;if(!((e=this.sharesEncryptedKeys)!=null&&e.length))return;let r="";try{this.sharesEncryptedKeys.map(t=>{let s=t;s.startsWith("0x")&&(r=s,s=cr.eth.abi.decodeParameter("string",t)),(0,er.decode)(String(s))})}catch(t){throw Error(`Can not ABI decode shares encrypted key: ${r}. Error: ${String(t)}`)}})}validateCounts(){return n(this,null,function*(){var r,e;if(!(!((r=this.sharesEncryptedKeys)!=null&&r.length)||!((e=this.sharesPublicKeys)!=null&&e.length))&&(this.operatorIds.length!==this.sharesEncryptedKeys.length||this.operatorIds.length!==this.sharesPublicKeys.length||this.operatorIds.length!==this.operatorPublicKeys.length))throw Error("Length of operators and shares should be equal.")})}validateOperatorsPublicKeys(){return n(this,null,function*(){for(let r of this.operatorPublicKeys){let e=yield Z(r);if(e!==!0)throw Error(String(e))}})}validate(){return n(this,null,function*(){yield p.init(p.BLS12_381),yield this.validateCounts(),yield this.validateSharesPublicKeys(),yield this.validateValidatorPublicKey(),yield this.validateSharesEncryptedKeys(),yield this.validateOperatorsPublicKeys()})}};h([(0,y.IsString)(),(0,y.Length)(98,98)],g.prototype,"publicKey",2),h([(0,y.ValidateNested)()],g.prototype,"operators",2),h([(0,y.IsOptional)(),(0,y.ValidateNested)()],g.prototype,"shares",2);var V=c("class-validator"),x=class{constructor(r){this.explained={};this.raw="";this.explained=r.explained||{},this.raw=r.raw||""}validate(){return n(this,null,function*(){})}};h([(0,V.IsObject)()],x.prototype,"explained",2),h([(0,V.IsString)()],x.prototype,"raw",2);var T=class{constructor({version:r,data:e,payload:t}){this.version=r,this.data=e,this.payload=t}setPayload(r){return n(this,null,function*(){return this.payload=r,yield this.payload.validate(),this})}setData(r){return n(this,null,function*(){return this.data=r,yield this.data.validate(),this})}static fromData(r){return n(this,null,function*(){typeof r=="string"&&(r=JSON.parse(r));let e,t;switch(r.version){case T.VERSION_V2:e=new g(r.data||{}),t=new x(r.payload||{});break;default:throw Error(`Keyshares version is not supported: ${r.version}`)}let s=new T({version:r.version,data:e,payload:t});yield(0,u.validateOrReject)(s).catch(i=>{throw Error(`Keyshares file have wrong format. Errors: ${JSON.stringify(i,null,"  ")}`)});try{yield s.data.validate()}catch(i){throw Error(`Keyshares data did not pass validation. Errors: ${i.message||i.stack||i.trace||String(i)}`)}try{yield s.payload.validate()}catch(i){throw Error(`Keyshares payload did not pass validation. Errors: ${i.message||i.stack||i.trace||String(i)}`)}return s})}toString(){return JSON.stringify({version:this.version,data:this.data,payload:this.payload,createdAt:new Date().toISOString()},null,"  ")}},b=T;b.VERSION_V2="v2",h([(0,u.IsString)(),(0,u.IsDefined)(),(0,u.IsNotEmpty)()],b.prototype,"version",2),h([(0,u.ValidateNested)()],b.prototype,"data",2),h([(0,u.ValidateNested)()],b.prototype,"payload",2);})();
