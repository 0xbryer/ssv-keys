(()=>{var te=Object.create;var k=Object.defineProperty;var j=Object.getOwnPropertyDescriptor;var se=Object.getOwnPropertyNames;var ae=Object.getPrototypeOf,ie=Object.prototype.hasOwnProperty;var c=(i=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(i,{get:(e,r)=>(typeof require!="undefined"?require:e)[r]}):i)(function(i){if(typeof require!="undefined")return require.apply(this,arguments);throw new Error('Dynamic require of "'+i+'" is not supported')});var ne=(i,e)=>{for(var r in e)k(i,r,{get:e[r],enumerable:!0})},oe=(i,e,r,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of se(e))!ie.call(i,s)&&s!==r&&k(i,s,{get:()=>e[s],enumerable:!(t=j(e,s))||t.enumerable});return i};var S=(i,e,r)=>(r=i!=null?te(ae(i)):{},oe(e||!i||!i.__esModule?k(r,"default",{value:i,enumerable:!0}):r,i));var h=(i,e,r,t)=>{for(var s=t>1?void 0:t?j(e,r):e,a=i.length-1,n;a>=0;a--)(n=i[a])&&(s=(t?n(e,r,s):n(s))||s);return t&&s&&k(e,r,s),s};var o=(i,e,r)=>new Promise((t,s)=>{var a=d=>{try{l(r.next(d))}catch(m){s(m)}},n=d=>{try{l(r.throw(d))}catch(m){s(m)}},l=d=>d.done?t(d.value):Promise.resolve(d.value).then(a,n);l((r=r.apply(i,e)).next())});var G=S(c("atob")),q=S(c("web3")),L=c("js-base64"),M=S(c("eth2-keystore-js"));var W;try{window.crypto,W=c("bls-eth-wasm/browser")}catch(i){W=c("bls-eth-wasm")}var p=W;var $=class extends Error{constructor(r,t){super(t);this.operators=r}},_=class extends Error{constructor(r,t){super(t);this.operator=r}},F=class{constructor(){this.shares=[]}static get DEFAULT_THRESHOLD_NUMBER(){return 3}create(e,r){return o(this,null,function*(){r.map(s=>{if(!Number.isInteger(s))throw new _(s,`Operator must be integer. Got: ${String(s)}`)});let t=(r.length-1)/3;if(!Number.isInteger(t))throw new $(r,"Invalid operators length. It should satisfy conditions: \u2016 Operators \u2016 := 3 * F + 1 ; F \u2208 \u2115");return new Promise((s,a)=>{try{p.init(p.BLS12_381).then(()=>{let n=[],l=[];this.validatorPrivateKey=p.deserializeHexStrToSecretKey(e),this.validatorPublicKey=this.validatorPrivateKey.getPublicKey(),n.push(this.validatorPrivateKey),l.push(this.validatorPublicKey);for(let m=1;m<r.length-t;m+=1){let f=new p.SecretKey;f.setByCSPRNG(),n.push(f);let K=f.getPublicKey();l.push(K)}for(let m of r){let f=new p.Id;f.setInt(m);let K=new p.SecretKey;K.share(n,f);let I=new p.PublicKey;I.share(l,f),this.shares.push({privateKey:`0x${K.serializeToHexStr()}`,publicKey:`0x${I.serializeToHexStr()}`,id:f})}let d={validatorPrivateKey:`0x${this.validatorPrivateKey.serializeToHexStr()}`,validatorPublicKey:`0x${this.validatorPublicKey.serializeToHexStr()}`,shares:this.shares};s(d)})}catch(n){a(n)}})})}},B=F;var D=c("js-base64");var C;try{window.crypto,C=c("jsencrypt").JSEncrypt}catch(i){C=c("node-jsencrypt")}var O=C;var P=class extends Error{constructor(r,t){super(t);this.operator=r}},v=class{constructor(e,r){this.RAW_OPERATOR_PUBLIC_KEY_SIGNATURE=RegExp(/------BEGIN RSA PUBLIC KEY-----/,"gmi");this.operators=e.map(t=>this.RAW_OPERATOR_PUBLIC_KEY_SIGNATURE.test(t)?t:(0,D.decode)(t)),this.shares=r}encrypt(){let e=[];return Object.keys(this.operators).forEach(r=>{let t=new O({});try{t.setPublicKey(this.operators[r])}catch(n){throw new P({rsa:this.operators[r],base64:(0,D.encode)(this.operators[r])},`Operator is not valid RSA Public Key: ${n}`)}let s=t.encrypt(this.shares[r].privateKey),a={operatorPublicKey:this.operators[r],privateKey:String(s),publicKey:this.shares[r].publicKey};return e.push(a),a}),e}};var H=class{constructor(){this.web3Instances={}}getWeb3(e=process.env.NODE_URL||""){return this.web3Instances[e]||(this.web3Instances[e]=new q.default(String(e||""))),this.web3Instances[e]}getPrivateKeyFromKeystoreData(e,r){return o(this,null,function*(){try{try{e=JSON.parse(e)}catch(s){}return yield new M.default(e).getPrivateKey(r).then(s=>s)}catch(t){return t}})}createThreshold(e,r){return o(this,null,function*(){try{return new B().create(e,r)}catch(t){return t}})}encryptShares(e,r,t=""){return o(this,null,function*(){try{let s=e.map(n=>String((0,L.encode)((0,G.default)(n))));return new v(s,r).encrypt().map(n=>(n.operatorPublicKey=(0,L.encode)(n.operatorPublicKey),t===H.SHARES_FORMAT_ABI&&(n.operatorPublicKey=this.getWeb3().eth.abi.encodeParameter("string",n.operatorPublicKey),n.privateKey=this.getWeb3().eth.abi.encodeParameter("string",n.privateKey)),n))}catch(s){return s}})}abiEncode(e,r){return e.map(t=>{let s=Object(t)[r];return String(s).startsWith("0x")?s:this.getWeb3().eth.abi.encodeParameter("string",s)})}buildPayload(e,r,t,s){return o(this,null,function*(){let a=t.map(l=>l.publicKey),n=this.abiEncode(t,"privateKey");return[e,r.join(","),a,n,s]})}},A=H;A.SHARES_FORMAT_ABI="abi";var J=S(c("crypto")),Y=c("scrypt-js"),R=S(c("ethereumjs-wallet")),N=c("ethereumjs-util"),U=class{constructor(e){this.privateKey="";if(!e)throw new Error("Key store data should be JSON or string");if(this.keyStoreData=JSON.parse(String(e)),!this.keyStoreData.version)throw new Error("Invalid keystore file")}getPublicKey(){var e;if(this.keyStoreData)switch((e=this.keyStoreData.version)!=null?e:this.keyStoreData.Version){case 1:return this.keyStoreData.Address;case 3:return this.keyStoreData.id;case 4:return this.keyStoreData.pubkey}return""}getPrivateKey(e=""){return o(this,null,function*(){if(this.privateKey)return this.privateKey;switch(this.keyStoreData.version){case 1:this.wallet=yield R.default.fromV1(this.keyStoreData,e);break;case 3:this.wallet=yield R.default.fromV3(this.keyStoreData,e,!0);break;case 4:this.wallet=yield this.fromV4(this.keyStoreData,e);break}if(this.wallet&&(this.privateKey=this.wallet.getPrivateKey().toString("hex"),!this.privateKey))throw new Error("Invalid password");return this.privateKey})}fromV4(e,r){return o(this,null,function*(){let t=typeof e=="object"?e:JSON.parse(e);if(t.version!==4)throw new Error("Not a V4 wallet");let s,a;if(t.crypto.kdf.function==="scrypt")a=t.crypto.kdf.params,s=yield(0,Y.scrypt)(Buffer.from(r),Buffer.from(a.salt,"hex"),a.n,a.r,a.p,a.dklen);else if(t.crypto.kdf.function==="pbkdf2"){if(a=t.crypto.kdf.params,a.prf!=="hmac-sha256")throw new Error("Unsupported parameters to PBKDF2");s=J.default.pbkdf2Sync(Buffer.from(r),Buffer.from(a.salt,"hex"),a.c,a.dklen,"sha256")}else throw new Error("Unsupported key derivation scheme");let n=Buffer.from(t.crypto.cipher.message,"hex"),l=Buffer.concat([Buffer.from(s.slice(16,32)),n]);if({keccak256:N.keccak256,sha256:N.sha256}[t.crypto.checksum.function](l).toString("hex")!==t.crypto.checksum.message)throw new Error("Invalid password");let K=J.default.createDecipheriv(t.crypto.cipher.function,s.slice(0,16),Buffer.from(t.crypto.cipher.params.iv,"hex")),I=this.runCipherBuffer(K,n);return new R.default(I)})}runCipherBuffer(e,r){return Buffer.concat([e.update(r),e.final()])}static toHexString(e){return Array.from(e,r=>`0${(r&255).toString(16)}`.slice(-2)).join("")}},Q=U;var u=c("class-validator");var z={};ne(z,{KeySharesDataV2:()=>g,KeySharesKeysV2:()=>w,OperatorV2:()=>E});var ee=S(c("web3")),re=c("js-base64"),y=c("class-validator");var X=c("js-base64");var Z=i=>o(void 0,null,function*(){try{let e="Invalid operator key format, make sure the operator exists in the network",r=(0,X.decode)(i);if(!r.startsWith("-----BEGIN RSA PUBLIC KEY-----"))throw Error(e);let t=new O({});try{t.setPublicKey(r)}catch(s){throw new P({rsa:r,base64:i},e)}return!0}catch(e){let{message:r}=e;return r}});var ce=new ee.default,w=class{constructor(e,r){this.publicKeys=e,this.encryptedKeys=r}toEncryptShares(e){if(this.publicKeys.length!==this.encryptedKeys.length||this.publicKeys.length!==e.length||this.encryptedKeys.length!==e.length)throw Error("Operator public keys and shares public/encrypted keys length does not match.");let r=[];for(let t=0;t<e.length;t+=1){let s=e[t],a=this.encryptedKeys[t],n=this.publicKeys[t];r.push({operatorPublicKey:s,privateKey:a,publicKey:n})}return r}};h([(0,y.IsArray)(),(0,y.MinLength)(98,{each:!0})],w.prototype,"publicKeys",2),h([(0,y.IsArray)(),(0,y.MinLength)(98,{each:!0})],w.prototype,"encryptedKeys",2);var E=class{constructor(e,r){this.id=e,this.publicKey=r}};h([(0,y.IsInt)()],E.prototype,"id",2),h([(0,y.IsString)(),(0,y.MinLength)(98)],E.prototype,"publicKey",2);var g=class{constructor(e){this.publicKey=e.publicKey,this.operators=e.operators.map(r=>new E(r.id,r.publicKey)),this.shares=new w(e.shares.publicKeys,e.shares.encryptedKeys)}get sharesPublicKeys(){var e;return((e=this.shares)==null?void 0:e.publicKeys)||null}get sharesEncryptedKeys(){var e;return((e=this.shares)==null?void 0:e.encryptedKeys)||null}get operatorIds(){return this.operators.map(e=>e.id)}get operatorPublicKeys(){return this.operators.map(e=>e.publicKey)}validateValidatorPublicKey(){return o(this,null,function*(){try{p.deserializeHexStrToPublicKey(this.publicKey.replace("0x",""))}catch(e){throw Error(`Can not BLS deserialize validator public key: ${this.publicKey}. Error: ${String(e)}`)}})}validateSharesPublicKeys(){return o(this,null,function*(){var r;if(!((r=this.sharesPublicKeys)!=null&&r.length))return;let e="";try{for(let t of this.sharesPublicKeys)e=t,p.deserializeHexStrToPublicKey(t.replace("0x",""))}catch(t){throw Error(`Can not BLS deserialize shares public key: ${e}. Error: ${String(t)}`)}})}validateSharesEncryptedKeys(){return o(this,null,function*(){var r;if(!((r=this.sharesEncryptedKeys)!=null&&r.length))return;let e="";try{this.sharesEncryptedKeys.map(t=>{let s=t;s.startsWith("0x")&&(e=s,s=ce.eth.abi.decodeParameter("string",t)),(0,re.decode)(String(s))})}catch(t){throw Error(`Can not ABI decode shares encrypted key: ${e}. Error: ${String(t)}`)}})}validateCounts(){return o(this,null,function*(){var e,r;if(!(!((e=this.sharesEncryptedKeys)!=null&&e.length)||!((r=this.sharesPublicKeys)!=null&&r.length))&&(this.operatorIds.length!==this.sharesEncryptedKeys.length||this.operatorIds.length!==this.sharesPublicKeys.length||this.operatorIds.length!==this.operatorPublicKeys.length))throw Error("Length of operators and shares should be equal.")})}validateOperatorsPublicKeys(){return o(this,null,function*(){for(let e of this.operatorPublicKeys){let r=yield Z(e);if(r!==!0)throw Error(String(r))}})}validate(){return o(this,null,function*(){yield p.init(p.BLS12_381),yield this.validateCounts(),yield this.validateSharesPublicKeys(),yield this.validateValidatorPublicKey(),yield this.validateSharesEncryptedKeys(),yield this.validateOperatorsPublicKeys()})}};h([(0,y.IsString)(),(0,y.Length)(98,98)],g.prototype,"publicKey",2),h([(0,y.ValidateNested)()],g.prototype,"operators",2),h([(0,y.IsOptional)(),(0,y.ValidateNested)()],g.prototype,"shares",2);var V=c("class-validator"),x=class{constructor(e){this.explained={};this.raw="";this.explained=e.explained||{},this.raw=e.raw||""}validate(){return o(this,null,function*(){})}};h([(0,V.IsObject)()],x.prototype,"explained",2),h([(0,V.IsString)()],x.prototype,"raw",2);var T=class{constructor({version:e,data:r,payload:t}){this.version=e,this.data=r,this.payload=t}setPayload(e){return o(this,null,function*(){return this.payload=e,yield this.payload.validate(),this})}setData(e){return o(this,null,function*(){return this.data=e,yield this.data.validate(),this})}static fromData(e){return o(this,null,function*(){typeof e=="string"&&(e=JSON.parse(e));let r,t;switch(e.version){case T.VERSION_V2:r=new g(e.data||{}),t=new x(e.payload||{});break;default:throw Error(`Keyshares version is not supported: ${e.version}`)}let s=new T({version:e.version,data:r,payload:t});yield(0,u.validateOrReject)(s).catch(a=>{throw Error(`Keyshares file have wrong format. Errors: ${JSON.stringify(a,null,"  ")}`)});try{yield s.data.validate()}catch(a){throw Error(`Keyshares data did not pass validation. Errors: ${a.message||a.stack||a.trace||String(a)}`)}try{yield s.payload.validate()}catch(a){throw Error(`Keyshares payload did not pass validation. Errors: ${a.message||a.stack||a.trace||String(a)}`)}return s})}toString(){return JSON.stringify({version:this.version,data:this.data,payload:this.payload,createdAt:new Date().toISOString()},null,"  ")}},b=T;b.VERSION_V2="v2",h([(0,u.IsString)(),(0,u.IsDefined)(),(0,u.IsNotEmpty)()],b.prototype,"version",2),h([(0,u.ValidateNested)()],b.prototype,"data",2),h([(0,u.ValidateNested)()],b.prototype,"payload",2);})();
